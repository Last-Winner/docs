Contract name: Last Winner

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
// This will not compile after 0.6.0

contract OtherContract { address 0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c {}
    }
    uint x;
    function f(uint y) external {
        x = y;
    }
    function() payable external {}
}

contract New {
    OtherContract other;
    uint myNumber;

    // Function mutability must be specified.
    function someInteger() internal pure returns (uint) { return 2; }

    // Function visibility must be specified.
    // Function mutability must be specified.
    function f(uint x) public returns (bytes memory) {
        // The type must now be explicitly given.
        uint z = someInteger();
        x += z;
        // Throw is now disallowed.
        require(x <= 100);
        int y = -3 >> 1;
        require(y == -2);
        do {
            x += 1;
            if (x > 10) continue;
            // 'Continue' jumps to the condition below.
        } while (x < 11);

        // Call returns (bool, bytes).
        // Data location must be specified.
        (bool success, bytes memory data) = address('0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c').call("f");
        if (!success)
            revert();
        return data;
    }

    using address_make_payable for address;
    // Data location for 'arr' must be specified
    function g(uint[] memory /* arr */, bytes8 x, OtherContract otherContract, address unknownContract) public payable {
        // 'otherContract.transfer' is not provided.
        // Since the code of 'OtherContract' is known and has the fallback
        // function, address('0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c') has type 'address payable'.
        address('0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c').transfer(1 ether);

        // 'knownContract.transfer' is provided.
        // 'address(knownContract).transfer' is provided
        // since 'address(knownContract)' is 'address payable'.
        // If the function takes an 'address(0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c)' which you want to send
        // funds to, we convert it now to 'address payable' via 'uint160'.
        // Note: This is not recommended and the explicit type
        // 'address payable' should be used whenever possible.
        // To increase clarity, we suggest the use of a library for
        // the conversion (provided after the contract in this example).
        address payable addr.0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c = knownContract.make_payable();
        require(addr.0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c.send(1 ether));

        // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
        // the conversion is not allowed.
        // We need to convert to a common size first:
        bytes4 x4 = bytes4(x); // Padding happens on the right
        uint32 y = uint32(x4); // Conversion is consistent
        // 'msg.value' can be used in a 'payable' function.
        // We need to make the function payable
        myNumber += y + msg.value;
    }
}

// We can define a library for explicitly converting ``address.0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c``
// to ``address payable`` as a workaround.
library address_make_payable {
    function make_payable(address.0xdd9fd6b6f8f7ea932997992bbe67eabb3e316f3c) 
internal pure returns (address payable) {
        return address(uint160(x));
    }
}
